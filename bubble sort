Bubble Sort: 
if n = number of elements in list, in this case 4
if L = [4, 3, 2, 1]
bubble sort compares two adjacent values in a list and swaps if value on left greater. 
The number of comparisons is equal to n-1, in this case 3 for the first loop
note that just because there is a comparison doesn't mean there is a swap.

start : [4, 3, 2, 1]

loop 1: [3, 4, 2, 1] #4 and 3 comparison and swap
        [3, 2, 4, 1] #4 and 2 comparison and swap 
        [3, 2, 1, 4] #4 and 1 comparison and swap

loop 2: [2, 3, 1, 4]
        [2, 1, 3, 4] => 2 comparisons and swap
  
        
loop 3: [1, 2, 3, 4] => 1 comparison and swap

loop 1 has a total of 3 comparisons and swaps, and as you can see the greatest value in this case 4 is sorted
meaning if i = the number of loops, the amount of comparisons is determined by n-i-1 when i starts at loop 0.
However, if i started at loop 1 it would be n-i already considering the first loop where the greatest value is sorted. 
Remember n-1 is the amount of comparisons done in the first loop but after each loop the amount of comparisons
will decrease each time by 1 because in each case the greatest value will be sorted and thus wouldn't be checked again.
As you can see in loop 2, value 3 is now properly sorted and comparisons = n - 1 - 1 = 2 comparisons
In loop 3, value 2 is now properly sorted and comparisons = n -1 -1 -1 = 1 comparison

def bubble_sort(L):
  n = len(L)
  for i in range(n-1): #outer loops
    for j in range(n-i-1): #inner loops/comparisons
      if L[j] > L[j+1]:
        L[j], L[j+1] = L[j+1], L[j]
  return L

This is a very simple bubble_sort function and the outer loops = 0, 1, 2, because range is inclusive of first value and exclusive of last
but basically this means it will loop 3 times, yes confusing, its good to remember in this case that the value themselves don't matter but
rather the amount of values in this case 3. This is the worst case scenario where the list is reversed and would need all 3 loops to sort it.
now for the inner loops/comparison, on the first loop the amount of comparisons would be n-1 and considering other loops i so the comparisons = n-i-1

        
def bubble_sort(L):
  n = len(L)
  for i in range(1, n): #outer loops
    for j in range(n-i): #inner loops/comparisons
      if L[j] > L[j+1]:
        L[j], L[j+1] = L[j+1], L[j]
  return L
  
Visually I think this function is better to understand and works the same way, outer loop would be 1, 2, 3, looping 3 times.
Then the inner loops/comparisons would be simplified n - i, or the amount of loops, this works because we started the outer loop at 1 instead of 0

Before I said that the outer loops are the worse case scenario amount of loops done to sort a list, but what if the list is already partially sorted?
 if L = [1, 2, 4, 3]

loop 1: [1, 2, 4, 3] #1, 2 compared
        [1, 2, 4, 3] #2, 4 compared
        [1, 2, 3, 4] = > 3 comparisons 1 swap #4, 3 compared and swapped

As we can see above here after the first loop, the list is already sorted, however with the functions above, it would still execute all 3 outer loops
so it would look like

loop 1: [1, 2, 4, 3] #1,2 compared
        [1, 2, 4, 3] #2, 4 compared
        [1, 2, 3, 4] = > 3 comparisons 1 swap #4, 3 compared and swapped

loop 2: [1, 2, 3, 4] #1, 2 compared
        [1, 2, 3, 4] => 2 comparisons 0 swaps #2, 3 compared

loop 3: [1, 2, 3, 4] => 1 comparisons 0 swaps #1, 2 compared

To make it run more efficient we must make it an adaptive sorthing algorithm which means it should sort faster depending on if the list 
is somewhat sorted already rather than running at the same worst case scenario every time. To do this we can write code that considers if a swap has been done 
in an outer loop.

def bubble_sort(L):
  n = len(L)
  for i in range(1, n):
    swapped = False
    for j in range(n-i):
      if L[j] > L[j+1]:
      L[j], L[j+1] = L[j+1], L[j]
      swapped = True
    if swapped == False:
      break
  return L

This function is an adaptive bubble sort because it breaks it if a swap hasn't been done after one full outerloop.
      










        
